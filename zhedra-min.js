var Zdog,Zhedra={setCoords:t=>({x:t.x?t.x:0,y:t.y?t.y:0,z:t.z?t.z:0}),Tetra:class{constructor(t){this.children="WIP";let o,s=["addTo","color","fill","stroke","colors"],r=Math.cos(Zdog.TAU/6)/2,e=.5+r,a={x:0,y:0,z:0};this.anchor=new Zdog.Anchor({addTo:t.addTo,translate:t.translate||a,rotate:t.rotate||a,scale:t.scale||a});let l=this.anchor;o=Zdog.TAU/3;let h=t=>({addTo:l,rotate:{y:o*t}});this.anchor1=[new Zdog.Anchor(h(0)),new Zdog.Anchor(h(-1)),new Zdog.Anchor(h(-2))];let c=this.anchor1;o=-1*Math.acos(1/3)+Zdog.TAU/4,h=(t=>({addTo:c[t],translate:{z:r,y:e/2},rotate:{x:o}})),this.anchor2=[new Zdog.Anchor(h(0)),new Zdog.Anchor(h(1)),new Zdog.Anchor(h(2))],c=null;let i=this.anchor2;h=((o,s,r)=>({addTo:o,translate:{y:s},rotate:r,radius:.5,sides:3,color:t.colors?t.colors[0]:t.color,fill:t.fill,stroke:t.stroke})),this.parts=[new Zdog.Polygon(h(l,e/2,{x:-Zdog.TAU/4,z:-Zdog.TAU/2})),new Zdog.Polygon(h(i[0],-r,0)),new Zdog.Polygon(h(i[1],-r,0)),new Zdog.Polygon(h(i[2],-r,0))],i=null,this.translate=t.translate||{},this.rotate=t.rotate||{},this.scale=t.scale||1;for(let o=0;o<s.length;o++)void 0!==t[s[o]]&&(this["_"+s[o]]=t[s[o]])}get addTo(){return this._addTo}get translate(){return this._translate}get rotate(){return this._rotate}get scale(){return this._scale}get color(){return this._color}get fill(){return this._fill}get stroke(){return this._stroke}get colors(){return this._frontFace}set addTo(t){this._addTo=this.anchor.addTo=t}set translate(t){this._translate=this.anchor.translate=Zhedra.setCoords(t)}set rotate(t){this._rotate=this.anchor.rotate=Zhedra.setCoords(t)}set scale(t){this._scale=this.anchor.scale="object"==typeof t?Zhedra.setCoords(t):t}set color(t){this._color=t,this.parts.forEach(o=>{o.color=t})}set fill(t){this._fill=t,this.parts.forEach(o=>{o.fill=t})}set stroke(t){this._stroke=t,this.parts.forEach(o=>{o.stroke=t})}set colors(t){this._colors=t,this.parts.forEach((o,s)=>{o.color=t[s]})}remove(t){this.addTo&&this.addTo.removeChild(this)}copy(t){new Zhedra.Tetra({addTo:t.addTo||this.addTo,translate:t.translate||this.translate,rotate:t.rotate||this.rotate,scale:t.scale||this.scale,color:t.color||this.color,fill:t.fill||this.fill,stroke:t.stroke||this.stroke,colors:t.colors||this.colors})}},Cube:class{constructor(t){this.children="WIP";let o=["addTo","color","fill","stroke","colors"];this.anchor=new Zdog.Anchor({addTo:t.addTo,translate:t.translate,rotate:t.rotate,scale:t.scale});let s,r,e=this.anchor,a=.5,l=Zdog.TAU/4;this.parts=[],this.parts[0]=s=new Zdog.Rect({addTo:e,length:1,width:1,fill:t.fill,stroke:t.stroke,translate:{y:a},rotate:{x:l},color:t.colors?t.colors[0]:t.color}),r=((o,s,r)=>({translate:s,rotate:r,color:t.colors?t.colors[o]:t.color})),this.parts[1]=s.copy(r(1,{z:a},{})),this.parts[2]=s.copy(r(2,{x:a},{y:l})),this.parts[3]=s.copy(r(3,{z:-a},{})),this.parts[4]=s.copy(r(4,{x:-a},{y:l})),this.parts[5]=s.copy(r(5,{y:-a},{x:-l})),this.translate=t.translate||{},this.rotate=t.rotate||{},this.scale=t.scale||1;for(let s=0;s<o.length;s++)void 0!==t[o[s]]&&(this["_"+o[s]]=t[o[s]])}get addTo(){return this._addTo}get translate(){return this._translate}get rotate(){return this._rotate}get scale(){return this._scale}get color(){return this._color}get fill(){return this._fill}get colors(){return this._colors}set addTo(t){this._addTo=this.anchor.addTo=t}set translate(t){this._translate=this.anchor.translate=this.setCoords(t)}set rotate(t){this._rotate=this.anchor.rotate=this.setCoords(t)}set scale(t){this._scale=this.anchor.scale="object"==typeof t?this.setCoords(t):t}set color(t){this._color=t,this.parts.forEach(o=>{o.color=t})}set fill(t){this._fill=t,this.parts.forEach(o=>{o.fill=t})}set stroke(t){this._stroke=t,this.parts.forEach(o=>{o.stroke=t})}set colors(t){this._colors=t,this.parts.forEach((o,s)=>{o.color=t[s]})}remove(t){this.addTo&&this.addTo.removeChild(this)}copy(t){new Zhedra.Cube({addTo:t.addTo||this.addTo,translate:t.translate||this.translate,rotate:t.rotate||this.rotate,scale:t.scale||this.scale,color:t.color||this.color,fill:t.fill||this.fill,stroke:t.stroke||this.stroke,colors:t.colors||this.colors})}},Octa:class{constructor(t){this.children="WIP";let o,s=["addTo","translate","rotate","scale","color","fill","stroke","colors"],r=Math.sqrt(3)/2*2/3,e=3*r/2,a=Math.asin(.5/e);this.anchor=new Zdog.Anchor({addTo:t.addTo,translate:{x:t.translate.x,y:t.translate.y,z:t.translate.z},rotate:t.rotate||{x:0,y:0,z:0},scale:.7*t.scale});let l=this.anchor;o=Zdog.TAU/4;let h=t=>({addTo:l,rotate:{y:-o*(t+1.5)}});this.anchor1=[new Zdog.Anchor(h(0)),new Zdog.Anchor(h(1)),new Zdog.Anchor(h(2)),new Zdog.Anchor(h(3))];let c=this.anchor1;this.anchor2=[],o=-1;for(let t=0;t<8;t++)this.anchor2.push(new Zdog.Anchor({addTo:c[t%4],translate:{z:.5},rotate:{x:a*o}})),o=3===t?1:o;c=null;let i=this.anchor2;this.parts=[],o=-1;for(let s=0;s<8;s++)this.parts.push(new Zdog.Polygon({sides:3,radius:r,addTo:i[s],translate:{y:-r/2*o},scale:{y:o},stroke:t.stroke,fill:t.fill,color:void 0===t.colors?t.color:t.colors[s]})),o=3===s?1:o;i=null;for(let o=0;o<s.length;o++)void 0!==t[s[o]]&&(this[s[o]]=t[s[o]])}get addTo(){return this._addTo}get translate(){return this._translate}get rotate(){return this._rotate}get scale(){return this._scale}get color(){return this._color}get fill(){return this._fill}get stroke(){return this._stroke}get colors(){return this._colors}set addTo(t){this._addTo=this.anchor.addTo=t}set translate(t){this._translate=this.anchor.translate=Zhedra.setCoords(t)}set rotate(t){this._rotate=this.anchor.rotate=Zhedra.setCoords(t)}set scale(t){this._scale=this.anchor.scale="object"==typeof t?Zhedra.setCoords(t):t}set color(t){this._color=t,this.parts.forEach(o=>{o.color=t})}set fill(t){this._fill=t,this.parts.forEach(o=>{o.fill=t})}set stroke(t){this._stroke=t,this.parts.forEach(o=>{o.stroke=t})}set colors(t){this._colors=t,this.parts.forEach((o,s)=>{o.color=t[s]})}remove(t){this.addTo&&this.addTo.removeChild(this)}copy(t){new Zhedra.Cube({addTo:t.addTo||this.addTo,translate:t.translate||this.translate,rotate:t.rotate||this.rotate,scale:t.scale||this.scale,color:t.color||this.color,fill:t.fill||this.fill,stroke:t.stroke||this.stroke,colors:t.colors||this.colors})}},Dodeca:class{constructor(t){this.children="WIP";let o=["addTo","translate","rotate","scale","color","fill","stroke","colors"],s=(1+Math.sqrt(5))/2,r=s*s/2;this.anchor=new Zdog.Anchor({addTo:t.addTo,translate:{x:t.translate.x,y:t.translate.y+4,z:t.translate.z},scale:.35*t.scale});let e=this.anchor;this.parts=[new Zdog.Polygon({sides:5,radius:1,addTo:e,translate:{y:-r},rotate:{x:Zdog.TAU/4},fill:t.fill,stroke:t.stroke,color:t.colors?t.colors[0]:t.color})];let a=this.parts[0];this.parts.push(a.copy({translate:{y:r},rotate:{x:-Zdog.TAU/4},color:t.colors?t.colors[0]:t.color})),s=Zdog.TAU/5;let l=t=>({addTo:e,rotate:{y:-s*t}});this.anchor1=[new Zdog.Anchor(l(0)),new Zdog.Anchor(l(1)),new Zdog.Anchor(l(2)),new Zdog.Anchor(l(3)),new Zdog.Anchor(l(4))];let h=this.anchor1;this.anchor2=[],s=-1;for(let t=0;t<10;t++)this.anchor2.push(new Zdog.Anchor({addTo:h[t%5],rotate:{x:Zdog.TAU/4*s-Math.atan(2)}})),s=4===t?1:s;h=null;let c=this.anchor2;s=-1;for(let o=0;o<10;o++)this.parts.push(a.copy({addTo:c[o],translate:{z:r},rotate:{z:Zdog.TAU/2},color:t.colors?t.colors[o+2]:t.color})),s=3===o?1:s;c=null;for(let s=0;s<o.length;s++)void 0!==t[o[s]]&&(this[o[s]]=t[o[s]])}get addTo(){return this._addTo}get translate(){return this._translate}get rotate(){return this._rotate}get scale(){return this._scale}get color(){return this._color}get fill(){return this._fill}get stroke(){return this._stroke}get colors(){return this._colors}set addTo(t){this._addTo=this.anchor.addTo=t}set translate(t){this._translate=this.anchor.translate=Zhedra.setCoords(t)}set rotate(t){this._rotate=this.anchor.rotate=Zhedra.setCoords(t)}set scale(t){this._scale=this.anchor.scale="object"==typeof t?Zhedra.setCoords(t):t}set color(t){this._color=t,this.parts.forEach(o=>{o.color=t})}set fill(t){this._fill=t,this.parts.forEach(o=>{o.fill=t})}set stroke(t){this._stroke=t,this.parts.forEach(o=>{o.stroke=t})}set colors(t){this._colors=t,this.parts.forEach((o,s)=>{o.color=t[s]})}remove(t){this.addTo&&this.addTo.removeChild(this)}copy(t){new Zhedra.Cube({addTo:t.addTo||this.addTo,translate:t.translate||this.translate,rotate:t.rotate||this.rotate,scale:t.scale||this.scale,color:t.color||this.color,fill:t.fill||this.fill,stroke:t.stroke||this.stroke,colors:t.colors||this.colors})}},Icosa:class{constructor(t){this.children="WIP";let o,s,r,e,a=["addTo","translate","rotate","scale","color","fill","stroke","colors"],l=Math.sqrt(3)/2*2/3,h=3*l/2,c=.5/Math.tan(Zdog.TAU/10),i=.5/Math.sin(Zdog.TAU/10),d=Math.asin(c/h),n=i-c,g=Math.asin(n/h),T=Math.sqrt(h*h-n*n);this.anchor=new Zdog.Anchor({addTo:t.addTo,translate:{x:t.translate.x,y:t.translate.y,z:t.translate.z},scale:.5*t.scale});let f=this.anchor;o=-1;let _=!1,Z=new Zdog.Polygon({sides:3,radius:l,addTo:null,stroke:t.stroke,fill:t.fill,color:null});for(this.anchor1=[],this.anchor2=[],this.parts=[],s=0;s<20;s++){this.anchor1.push(new Zdog.Anchor({addTo:f,rotate:{y:-Zdog.TAU/5*(s%5)},translate:{y:T/2*o}}));let a=this.anchor1[s];r=-d+(o<0?0:Zdog.TAU/2),e=-g+(o<0?Zdog.TAU/2:0),this.anchor2.push(new Zdog.Anchor({addTo:a,translate:{z:c*o},rotate:{x:_?e:r}}));let h=this.anchor2[s];this.parts.push(Z.copy({addTo:h,translate:{y:-l/2},rotate:{y:o?Zdog.TAU/2:0},color:t.colors?t.colors[s]:t.color})),o=9===s?1:o,s%5==4&&(_=!_)}for(let o=0;o<a.length;o++)void 0!==t[a[o]]&&(this[a[o]]=t[a[o]])}get addTo(){return this._addTo}get translate(){return this._translate}get rotate(){return this._rotate}get scale(){return this._scale}get color(){return this._color}get fill(){return this._fill}get stroke(){return this._stroke}get colors(){return this._colors}set addTo(t){this._addTo=this.anchor.addTo=t}set translate(t){this._translate=this.anchor.translate=Zhedra.setCoords(t)}set rotate(t){this._rotate=this.anchor.rotate=Zhedra.setCoords(t)}set scale(t){this._scale=this.anchor.scale="object"==typeof t?Zhedra.setCoords(t):t}set color(t){this._color=t,this.parts.forEach(o=>{o.color=t})}set fill(t){this._fill=t,this.parts.forEach(o=>{o.fill=t})}set stroke(t){this._stroke=t,this.parts.forEach(o=>{o.stroke=t})}set colors(t){this._colors=t,this.parts.forEach((o,s)=>{o.color=t[s]})}remove(t){this.addTo&&this.addTo.removeChild(this)}copy(t){new Zhedra.Icosa({addTo:t.addTo||this.addTo,translate:t.translate||this.translate,rotate:t.rotate||this.rotate,scale:t.scale||this.scale,color:t.color||this.color,fill:t.fill||this.fill,stroke:t.stroke||this.stroke,colors:t.colors||this.colors})}},init:function(){Zdog.Tetra=Zhedra.Tetra,Zdog.Cube=Zhedra.Cube,Zdog.Octa=Zhedra.Octa,Zdog.Dodeca=Zhedra.Dodeca,Zdog.Icosa=Zhedra.Icosa}};
